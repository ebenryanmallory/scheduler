/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core'
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'

declare let self: ServiceWorkerGlobalScope

// Take control immediately
clientsClaim()

// Clean up old caches
cleanupOutdatedCaches()

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST)

// Background Sync for offline operations
const SYNC_TAG = 'scheduler-sync'

/**
 * Listen for sync events
 */
self.addEventListener('sync', (event) => {
  if (event.tag === SYNC_TAG) {
    console.log('[SW] Background sync triggered')
    event.waitUntil(syncPendingOperations())
  }
})

/**
 * Sync pending operations from IndexedDB
 */
async function syncPendingOperations(): Promise<void> {
  try {
    // Open the scheduler database
    const db = await openSchedulerDB()
    if (!db) {
      console.log('[SW] Could not open database for sync')
      return
    }

    // Get pending operations
    const tx = db.transaction('operations', 'readonly')
    const store = tx.objectStore('operations')
    const index = store.index('synced')
    const pending = await getAllFromIndex(index, IDBKeyRange.only(false))

    if (pending.length === 0) {
      console.log('[SW] No pending operations to sync')
      return
    }

    console.log(`[SW] Syncing ${pending.length} pending operations`)

    // Process each operation
    for (const operation of pending) {
      try {
        await processOperation(operation)
        // Mark as synced
        await markOperationSynced(db, operation.id)
      } catch (error) {
        console.error(`[SW] Failed to sync operation ${operation.id}:`, error)
        await incrementRetryCount(db, operation.id)
      }
    }

    // Notify clients about sync completion
    const clients = await self.clients.matchAll()
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_COMPLETE',
        syncedCount: pending.length
      })
    })
  } catch (error) {
    console.error('[SW] Background sync failed:', error)
  }
}

/**
 * Process a single operation
 */
async function processOperation(operation: {
  type: string
  entity: string
  entityId: string
  payload: unknown
}): Promise<void> {
  const { type, entity, entityId, payload } = operation
  const baseUrl = '/api'
  
  let url: string
  let method: string
  let body: string | undefined

  switch (type) {
    case 'create':
      url = `${baseUrl}/${entity}s`
      method = 'POST'
      body = JSON.stringify(payload)
      break
    case 'update':
      url = `${baseUrl}/${entity}s/${entityId}`
      method = 'PUT'
      body = JSON.stringify(payload)
      break
    case 'delete':
      url = `${baseUrl}/${entity}s/${entityId}`
      method = 'DELETE'
      break
    default:
      throw new Error(`Unknown operation type: ${type}`)
  }

  const response = await fetch(url, {
    method,
    headers: body ? { 'Content-Type': 'application/json' } : undefined,
    body
  })

  if (!response.ok) {
    throw new Error(`Server returned ${response.status}`)
  }
}

/**
 * Open the scheduler IndexedDB database
 */
function openSchedulerDB(): Promise<IDBDatabase | null> {
  return new Promise((resolve) => {
    const request = indexedDB.open('scheduler-offline')
    
    request.onerror = () => {
      console.error('[SW] Failed to open database')
      resolve(null)
    }
    
    request.onsuccess = () => {
      resolve(request.result)
    }
  })
}

/**
 * Get all records from an index
 */
function getAllFromIndex(
  index: IDBIndex,
  query: IDBKeyRange
): Promise<Array<{id: number; type: string; entity: string; entityId: string; payload: unknown}>> {
  return new Promise((resolve, reject) => {
    const request = index.getAll(query)
    request.onsuccess = () => resolve(request.result || [])
    request.onerror = () => reject(request.error)
  })
}

/**
 * Mark an operation as synced
 */
async function markOperationSynced(db: IDBDatabase, id: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('operations', 'readwrite')
    const store = tx.objectStore('operations')
    const request = store.get(id)
    
    request.onsuccess = () => {
      const record = request.result
      if (record) {
        record.synced = true
        store.put(record)
      }
      resolve()
    }
    request.onerror = () => reject(request.error)
  })
}

/**
 * Increment retry count for failed operation
 */
async function incrementRetryCount(db: IDBDatabase, id: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('operations', 'readwrite')
    const store = tx.objectStore('operations')
    const request = store.get(id)
    
    request.onsuccess = () => {
      const record = request.result
      if (record) {
        record.retryCount = (record.retryCount || 0) + 1
        store.put(record)
      }
      resolve()
    }
    request.onerror = () => reject(request.error)
  })
}

/**
 * Listen for messages from the main app
 */
self.addEventListener('message', (event) => {
  if (event.data?.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
  
  if (event.data?.type === 'TRIGGER_SYNC') {
    // Manual sync trigger from app
    // Background Sync API may not be available in all browsers
    if ('sync' in self.registration) {
      (self.registration as ServiceWorkerRegistration & { sync: { register: (tag: string) => Promise<void> } }).sync.register(SYNC_TAG)
    }
  }
})

/**
 * Handle fetch events for offline support
 */
self.addEventListener('fetch', (event) => {
  const { request } = event

  // Skip non-GET requests for now (let Workbox handle them)
  if (request.method !== 'GET') {
    return
  }

  // For API requests, try network first, fall back to cache
  if (request.url.includes('/api/')) {
    event.respondWith(
      fetch(request)
        .then(response => {
          // Clone and cache successful responses
          if (response.ok) {
            const responseClone = response.clone()
            caches.open('api-runtime-cache').then(cache => {
              cache.put(request, responseClone)
            })
          }
          return response
        })
        .catch(async () => {
          // Network failed, try cache
          const cachedResponse = await caches.match(request)
          if (cachedResponse) {
            return cachedResponse
          }
          // Return offline response
          return new Response(
            JSON.stringify({ error: 'offline', message: 'You are offline' }),
            {
              status: 503,
              headers: { 'Content-Type': 'application/json' }
            }
          )
        })
    )
  }
})

// Export for type checking
export {}

